<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>PimpPong Arena | ANTI-HACK EDITION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; color: #ffd700; font-family: 'Orbitron', sans-serif; overflow: hidden; touch-action: none; }
        canvas { position: absolute; top: 0; left: 0; display: block; width: 100%; height: 100%; z-index: 10; }
        .header { position: absolute; top: 0; width: 100%; padding: 15px; background: rgba(0,0,0,0.8); z-index: 100; border-bottom: 2px solid #ffd700; text-align: center; pointer-events: none; }
        #leaderboard { position: absolute; bottom: 15px; left: 15px; z-index: 20; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.4); width: 190px; pointer-events: none; }
        .leader-title { font-size: 0.65rem; color: #ffd700; text-align: center; margin-bottom: 5px; letter-spacing: 1px; }
        table { width: 100%; font-size: 0.6rem; border-collapse: collapse; color: #fff; }
        td { padding: 3px 0; border-bottom: 1px solid #222; }
        .overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 1000; }
        #popup { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #0a0a0a; border: 3px solid #ffd700; padding: 30px; z-index: 1100; border-radius: 20px; width: 85%; max-width: 380px; text-align: center; }
        #final-score { font-size: 3.5rem; color: #ffd700; margin: 10px 0; font-weight: 900; }
        input { width: 100%; padding: 15px; margin-bottom: 15px; background: #111; border: 1px solid #ffd700; color: #fff; font-family: 'Orbitron'; text-align: center; border-radius: 8px; font-size: 0.8rem; }
        .main-btn { background: #ffd700; color: #000; border: none; padding: 18px; font-weight: 900; width: 100%; cursor: pointer; border-radius: 10px; font-family: 'Orbitron'; font-size: 1.2rem; }
    </style>
</head>
<body>

<div class="header">
    <div style="font-size: 1.1rem;">SCORE: <span id="score">0</span> | BEST: <span id="high">0</span></div>
</div>

<canvas id="pongCanvas"></canvas>

<div id="leaderboard">
    <div class="leader-title">TOP CHALLENGERS</div>
    <table><tbody id="leader-rows"></tbody></table>
</div>

<div class="overlay" id="overlay"></div>
<div id="popup">
    <h2 id="status-text">GAME OVER</h2>
    <div id="final-score">0</div>
    <div id="input-container"></div>
    <button id="actionBtn" class="main-btn">TRY AGAIN</button>
</div>

<script>
const SUPABASE_URL = 'https://jmknzhsmlwqwzxguxfor.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Impta256aHNtbHdxd3p4Z3V4Zm9yIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgzMTk4ODQsImV4cCI6MjA4Mzg5NTg4NH0.ZKZ-lTZmc6HoLoAC-MuyejyQCL4WM9ZMgEU_x-yH_L0';
const PADDLE_URL = 'https://i.ibb.co/s06v3BX/image-8.png';
const EGG_URL = 'https://i.ibb.co/VYbXg81b/16220.png';

const canvas = document.getElementById("pongCanvas");
const ctx = canvas.getContext("2d");
const paddleImg = new Image(); paddleImg.src = PADDLE_URL;
const eggImg = new Image(); eggImg.src = EGG_URL;

let score = 0, gameActive = true, globalTopScores = [];
let wobble = 0, powerUpTimer = 0, collisionCooldown = 0;
let paddle = { x: 0, y: 0, w: 140, h: 0 }; 
const ball = { x: 150, y: 150, r: 20, dx: 5, dy: 5, isGold: false };

const MAX_SPEED = 18; // Verhindert Physik-Glitches

function resize() { 
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    if(paddleImg.complete) { paddle.h = paddle.w * (paddleImg.naturalHeight / paddleImg.naturalWidth); }
    paddle.x = canvas.width / 2 - paddle.w / 2; 
    paddle.y = canvas.height - 180;
}
window.addEventListener('resize', resize);
paddleImg.onload = resize;

async function loadScores() {
    try {
        const res = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard?select=wallet,score&order=score.desc&limit=3`, {
            headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}` }
        });
        const data = await res.json();
        if (data) {
            globalTopScores = data;
            document.getElementById("leader-rows").innerHTML = data.map((e,i)=>`<tr><td>${i+1}.</td><td>${e.wallet.substring(0,6)}...</td><td align="right">${e.score}</td></tr>`).join('');
            if(data[0]) document.getElementById("high").innerText = data[0].score;
        }
    } catch(e) {}
}

function checkCollision(pX, pY, pW, pH) {
    if (collisionCooldown > 0) return false;

    const visualOffset = 15;
    let closestX = Math.max(pX, Math.min(ball.x, pX + pW));
    let closestY = Math.max(pY + visualOffset, Math.min(ball.y, pY + pH));
    let dx = ball.x - closestX;
    let dy = ball.y - closestY;

    if ((dx * dx + dy * dy) < (ball.r * ball.r)) {
        collisionCooldown = 15; // Sperre für 15 Frames

        // Seitlicher Treffer: Drücke den Ball aktiv raus
        if (Math.abs(dx) > Math.abs(dy) + 2) {
            ball.dx = (ball.x < pX + pW/2) ? -Math.abs(ball.dx) * 1.1 : Math.abs(ball.dx) * 1.1;
            ball.x = (ball.x < pX + pW/2) ? pX - ball.r - 2 : pX + pW + ball.r + 2;
        } else {
            // Treffer von oben
            ball.dy = -Math.abs(ball.dy) * 1.05;
            ball.y = pY + visualOffset - ball.r + 5;
        }
        
        // Speed Limit Cap
        if(Math.abs(ball.dx) > MAX_SPEED) ball.dx = MAX_SPEED * Math.sign(ball.dx);
        if(Math.abs(ball.dy) > MAX_SPEED) ball.dy = MAX_SPEED * Math.sign(ball.dy);

        return true;
    }
    return false;
}

function showPopup() {
    gameActive = false;
    const currentHigh = parseInt(document.getElementById("high").innerText) || 0;
    const isNewHighscore = score > 0 && (globalTopScores.length < 3 || score > (globalTopScores[2]?.score || 0) || score > currentHigh);

    document.getElementById("final-score").innerText = score;
    document.getElementById("overlay").style.display = "block";
    document.getElementById("popup").style.display = "block";

    if (isNewHighscore) {
        document.getElementById("status-text").innerText = "NEW ARENA RECORD!";
        document.getElementById("input-container").innerHTML = '<input type="text" id="walletInput" placeholder="ENTER SOLANA WALLET">';
        document.getElementById("actionBtn").innerText = "SUBMIT SCORE";
        document.getElementById("actionBtn").onclick = () => {
            const val = document.getElementById("walletInput").value.trim();
            if (val.length >= 5) saveScore(val);
        };
    } else {
        document.getElementById("status-text").innerText = "GAME OVER";
        document.getElementById("actionBtn").innerText = "TRY AGAIN";
        document.getElementById("actionBtn").onclick = () => window.location.reload();
    }
}

async function saveScore(wallet) {
    const btn = document.getElementById("actionBtn"); btn.innerText = "SAVING..."; btn.disabled = true;
    try {
        await fetch(`${SUPABASE_URL}/rest/v1/leaderboard`, {
            method: 'POST', 
            headers: { 'apikey': SUPABASE_KEY, 'Authorization': `Bearer ${SUPABASE_KEY}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ wallet: wallet, score: score })
        });
        window.location.reload();
    } catch(e) { btn.disabled = false; btn.innerText = "SUBMIT"; }
}

function draw() {
    if(!gameActive) return; 
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (collisionCooldown > 0) collisionCooldown--;
    if (ball.isGold) powerUpTimer--;
    if (powerUpTimer <= 0) ball.isGold = false;

    wobble += 0.15;
    let eggWidth = ball.r + Math.sin(wobble) * 4;

    if(paddleImg.complete) {
        ctx.drawImage(paddleImg, paddle.x, paddle.y, paddle.w, paddle.h);
        if (ball.isGold && (powerUpTimer >= 120 || Math.floor(powerUpTimer/12)%2 !== 0)) {
            ctx.drawImage(paddleImg, paddle.x + paddle.w + 10, paddle.y, paddle.w, paddle.h);
        }
    }

    ctx.save(); 
    ctx.translate(ball.x, ball.y);
    ctx.rotate(wobble * 0.4);
    if (ball.isGold) { ctx.shadowBlur = 35; ctx.shadowColor = "#ffd700"; }
    if(eggImg.complete) ctx.drawImage(eggImg, -eggWidth, -ball.r, eggWidth * 2, ball.r * 2);
    ctx.restore(); 

    ball.x += ball.dx; ball.y += ball.dy;

    if(ball.x + ball.r > canvas.width || ball.x - ball.r < 0) {
        ball.dx *= -1; 
        ball.x = (ball.x < ball.r) ? ball.r : canvas.width - ball.r;
    }
    if(ball.y - ball.r < 0) ball.dy = Math.abs(ball.dy);

    let hit1 = checkCollision(paddle.x, paddle.y, paddle.w, paddle.h);
    let extraVisible = ball.isGold && (powerUpTimer >= 120 || Math.floor(powerUpTimer/12)%2 !== 0);
    let hit2 = extraVisible && checkCollision(paddle.x + paddle.w + 10, paddle.y, paddle.w, paddle.h);

    if(hit1 || hit2) {
        ball.dx += (Math.random() - 0.5) * 6;
        score++;
        if (score % 10 === 0) { ball.isGold = true; powerUpTimer = 400; }
        document.getElementById("score").innerText = score; 
    }

    if(ball.y > canvas.height) showPopup(); 
    else requestAnimationFrame(draw);
}

const move = (e) => { 
    const clientX = (e.touches ? e.touches[0].clientX : e.clientX); 
    paddle.x = clientX - paddle.w/2; 
};
window.addEventListener("mousemove", move); 
window.addEventListener("touchmove", (e) => { move(e); e.preventDefault(); }, {passive:false});
loadScores(); resize(); draw();
</script>
</body>
</html>
